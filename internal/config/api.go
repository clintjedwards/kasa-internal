package config

import (
	"os"
	"sort"
	"strings"
	"time"

	"github.com/fatih/structs"
	"github.com/knadh/koanf/parsers/hcl"
	"github.com/knadh/koanf/providers/env"
	"github.com/knadh/koanf/providers/file"
	"github.com/knadh/koanf/v2"
)

// API refers to general application configuration
type API struct {
	Development *Development `koanf:"development"`
	Server      *Server      `koanf:"server"`
}

func DefaultAPIConfig() *API {
	return &API{
		Development: DefaultDevelopmentConfig(),
		Server:      DefaultServerConfig(),
	}
}

type Development struct {
	PrettyLogging   bool `koanf:"pretty_logging"`
	UseLocalhostTLS bool `koanf:"use_localhost_tls"`

	// Instead of having to recompile the static files into the binary during development for every change
	// instead uses another implementation of the fileserver to easily serve files from local disk.
	LoadFrontendFilesFromDisk bool `koanf:"load_frontend_files_from_disk"`

	// The OpenAPI files located in the root and sdk folders for the project are generated by huma(https://huma.rocks).
	// The root openapi.yaml file will autogenerate on application start if this is set to true.
	GenerateOpenAPISpecFiles bool `koanf:"generate_open_api_spec_files"`
}

func DefaultDevelopmentConfig() *Development {
	return &Development{
		PrettyLogging:             false,
		UseLocalhostTLS:           false,
		LoadFrontendFilesFromDisk: false,
		GenerateOpenAPISpecFiles:  false,
	}
}

func FullDevelopmentConfig() *Development {
	return &Development{
		PrettyLogging:             true,
		UseLocalhostTLS:           true,
		LoadFrontendFilesFromDisk: false,
		GenerateOpenAPISpecFiles:  false,
	}
}

// Server represents lower level HTTP/GRPC server settings.
type Server struct {
	// Log level affects the entire application's logs including launched extensions.
	LogLevel string `koanf:"log_level"`

	// The bind address the server will listen on. Ex: 0.0.0.0:8080
	ListenAddress string `koanf:"listen_address"`

	// The maximum duration for reading the entire request, including the body.
	ReadTimeout time.Duration `koanf:"read_timeout"`

	// WriteTimeout is the maximum duration before timing out writes of the response. It is reset whenever a new requestâ€™s header is read.
	WriteTimeout time.Duration `koanf:"write_timeout"`

	// IdleTimeout is the maximum amount of time to wait for the next request when keepalives are enabled.
	// If IdleTimeout is zero, the value of ReadTimeout is used.
	IdleTimeout time.Duration `koanf:"idle_timeout"`

	// How long the GRPC service should wait on in-progress connections before hard closing everything out.
	ShutdownTimeout time.Duration `koanf:"shutdown_timeout"`

	TLSCertPath string `koanf:"tls_cert_path"`
	TLSKeyPath  string `koanf:"tls_key_path"`
}

// DefaultServerConfig returns a pre-populated configuration struct that is used as the base for super imposing user configuration
// settings.
func DefaultServerConfig() *Server {
	return &Server{
		LogLevel:        "info",
		ListenAddress:   "0.0.0.0:8080",
		ReadTimeout:     10 * time.Second,
		WriteTimeout:    10 * time.Second,
		IdleTimeout:     15 * time.Second,
		ShutdownTimeout: mustParseDuration("15s"),
	}
}

// Get the final configuration for the server.
// This involves correctly finding and ordering different possible paths for the configuration file:
//
//  1. The function is intended to be called with paths gleaned from the -config flag in the cli.
//  2. If the user does not use the -config path of the path does not exist,
//     then we default to a few hard coded config path locations.
//  3. Then try to see if the user has set an envvar for the config file, which overrides
//     all previous config file paths.
//  4. Finally, whatever configuration file path is found first is the processed.
//
// Whether or not we use the configuration file we then search the environment for all environment variables:
//   - Environment variables are loaded after the config file and therefore overwrite any conflicting keys.
//   - All configuration that goes into a configuration file can also be used as an environment variable.
func InitAPIConfig(userDefinedPath string, loadDefaults bool, devMode bool) (*API, error) {
	var config *API

	// First we initiate the default values for the config.
	if loadDefaults {
		config = DefaultAPIConfig()
	}

	if devMode {
		config.Development = FullDevelopmentConfig()
	}

	possibleConfigPaths := []string{userDefinedPath, "/etc/innerhaven/innerhaven.hcl"}

	path := searchFilePaths(possibleConfigPaths...)

	// envVars top all other entries so if its not empty we just insert it over the current path
	// regardless of if we found one.
	envPath := os.Getenv("INNERHAVEN_CONFIG_PATH")
	if envPath != "" {
		path = envPath
	}

	configParser := koanf.New(".")

	if path != "" {
		err := configParser.Load(file.Provider(path), hcl.Parser(true))
		if err != nil {
			return nil, err
		}
	}

	err := configParser.Load(env.Provider("INNERHAVEN_", "__", func(s string) string {
		newStr := strings.TrimPrefix(s, "INNERHAVEN_")
		newStr = strings.ToLower(newStr)
		return newStr
	}), nil)
	if err != nil {
		return nil, err
	}

	err = configParser.Unmarshal("", &config)
	if err != nil {
		return nil, err
	}

	return config, nil
}

func GetAPIEnvVars() []string {
	api := API{
		Server:      &Server{},
		Development: &Development{},
	}
	fields := structs.Fields(api)

	vars := getEnvVarsFromStruct("INNERHAVEN_", fields)
	sort.Strings(vars)
	return vars
}
